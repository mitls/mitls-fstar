
type cipher =
AEAD_GCM.cipher

type dplain =
StatefulPlain.fragment

type entry =
| Entry of TLSInfo.id * cipher * StatefulPlain.adata * dplain

type st_log_t =
entry Seq.seq HyperHeap.rref

type gcm_log_t =
AEAD_GCM.entry Seq.seq HyperHeap.rref

type writer =
| StWriter of TLSInfo.id * HyperHeap.rid * st_log_t * LHAEPlain.seqn HyperHeap.rref * AEAD_GCM.encryptor

type reader =
| StReader of TLSInfo.id * HyperHeap.rid * st_log_t * LHAEPlain.seqn HyperHeap.rref * AEAD_GCM.decryptor

type both =
(reader * writer) 

let gen = (fun r0 i -> (let _41_52 = ()
in (let r = (HyperHeap.new_region r0)
in (let _41_57 = (AEAD_GCM.gen r i)
in (match (_41_57) with
| (enc, dec) -> begin
(let log = (HyperHeap.ralloc r (AEAD_GCM.emp))
in (let rd = StReader (((fun r0 i r _41_57 enc dec log -> i) r0 i r _41_57 enc dec log), ((fun r0 i r _41_57 enc dec log -> r) r0 i r _41_57 enc dec log), log, (HyperHeap.ralloc r 0), dec)
in (let wr = StWriter (((fun r0 i r _41_57 enc dec log rd -> i) r0 i r _41_57 enc dec log rd), ((fun r0 i r _41_57 enc dec log rd -> r) r0 i r _41_57 enc dec log rd), log, (HyperHeap.ralloc r 0), enc)
in (rd, wr))))
end)))))

let leak_reader = (fun i rd -> (AEAD_GCM.leak i TLSInfo.Reader ((fun _proj_ -> (match (_proj_) with
| StReader (i, region, log, seqn, key) -> begin
key
end)) rd)))

let leak_writer = (fun i wr -> (AEAD_GCM.leak i TLSInfo.Writer ((fun _proj_ -> (match (_proj_) with
| StWriter (i, region, log, seqn, key) -> begin
key
end))  wr)))

let coerce_reader = (fun r0 i kv iv -> (let _41_90 = ()
in (let r = (HyperHeap.new_region r0)
in (let dec = (AEAD_GCM.coerce r i TLSInfo.Reader kv iv)
in (let log = (HyperHeap.ralloc r (AEAD_GCM.emp))
in StReader (((fun r0 i kv iv r dec log -> i) r0 i kv iv r dec log), ((fun r0 i kv iv r dec log -> r) r0 i kv iv r dec log), log, (HyperHeap.ralloc r 0), dec))))))

let coerce_writer = (fun r0 i kv iv -> (let _41_108 = ()
in (let r = (HyperHeap.new_region r0)
in (let enc = (AEAD_GCM.coerce r i TLSInfo.Writer kv iv)
in (let log = (HyperHeap.ralloc r (AEAD_GCM.emp))
in StWriter (((fun r0 i kv iv r enc log -> i) r0 i kv iv r enc log), ((fun r0 i kv iv r enc log -> r) r0 i kv iv r enc log), log, (HyperHeap.ralloc r 0), enc))))))

let refs_in_e = (fun i e -> ())

let encrypt = (fun i ad rg _41_136 f -> (match (_41_136) with
| StWriter (ii, r, log, seqn, key) -> begin
(let n = (HyperHeap.op_Bang  seqn)
in (let l = (HyperHeap.op_Bang  log)
in (let ad' = (LHAEPlain.makeAD i n ad)
in (let c = (AEAD_GCM.encrypt i key ad' rg f)
in (let _41_142 = (HyperHeap.op_Colon_Equals log (AEAD_GCM.snoc l (Entry (((fun i ad rg _41_136 f ii r log seqn key n l ad' c -> i) i ad rg _41_136 f ii r log seqn key n l ad' c), c, ad, f))))
in (let _41_144 = (HyperHeap.op_Colon_Equals  seqn (n + 1))
in c))))))
end))

let decrypt = (fun i ad rd c -> (let _41_174 = rd
in (match (_41_174) with
| StReader (_41_4522, _41_4523, log, seqn, key) -> begin
(let _41_179 = ()
in (let n = (HyperHeap.op_Bang  seqn)
in (let _41_182 = ()
in (let ad' = (LHAEPlain.makeAD i n ad)
in (match ((AEAD_GCM.decrypt i key ad' c)) with
| Some (p) -> begin
(let _41_187 = (HyperHeap.op_Colon_Equals  seqn (n + 1))
in Some (p))
end
| None -> begin
None
end)))))
end)))




