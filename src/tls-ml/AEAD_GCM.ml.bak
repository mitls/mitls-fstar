
let snoc = (fun s x -> (Seq.append s (Seq.create 1 x)))

let emp = (Seq.createEmpty)

let rec seq_find_aux = (fun f l ctr -> (match (ctr) with
| 0 -> begin
None
end
| _ -> begin
(let i = (ctr - 1)
in if (f (Seq.index l i)) then begin
Some ((Seq.index l i))
end else begin
(seq_find_aux f l i)
end)
end))

let seq_find = (fun f l -> (let _40_38 = (Support.Prims.admit ())
in (seq_find_aux f l (Seq.length l))))

type cipher =
Platform.Bytes.bytes

type key =
Platform.Bytes.bytes

type iv =
Platform.Bytes.bytes

type counter =
Support.Prims.nat

type dplain =
LHAEPlain.plain

type entry =
| Entry of TLSInfo.id * cipher * LHAEPlain.adata * dplain

type state =
| State of TLSInfo.id * TLSInfo.rw * HyperHeap.rid * key * iv * entry Seq.seq HyperHeap.rref * counter HyperHeap.rref

type encryptor =
state

type decryptor =
state

let gen0 = (fun i -> ((Platform.Bytes.createBytes 1 '\x00'), (Platform.Bytes.createBytes 1 '\x00')))

let gen = (fun r0 i -> (let r = (HyperHeap.new_region r0)
in (let _40_79 = (gen0 i)
in (match (_40_79) with
| (kv, iv) -> begin
(let log = (HyperHeap.ralloc r (emp))
in (let ectr = (HyperHeap.ralloc r 0)
in (let dctr = (HyperHeap.ralloc r 0)
in (let enc = State (((fun r0 i r _40_79 kv iv log ectr dctr -> i) r0 i r _40_79 kv iv log ectr dctr), ((fun r0 i r _40_79 kv iv log ectr dctr -> TLSInfo.Writer) r0 i r _40_79 kv iv log ectr dctr), ((fun r0 i r _40_79 kv iv log ectr dctr -> r) r0 i r _40_79 kv iv log ectr dctr), kv, iv, log, ectr)
in (let dec = State (((fun r0 i r _40_79 kv iv log ectr dctr enc -> i) r0 i r _40_79 kv iv log ectr dctr enc), ((fun r0 i r _40_79 kv iv log ectr dctr enc -> TLSInfo.Reader) r0 i r _40_79 kv iv log ectr dctr enc), ((fun r0 i r _40_79 kv iv log ectr dctr enc -> r) r0 i r _40_79 kv iv log ectr dctr enc), kv, iv, log, dctr)
in (enc, dec))))))
end))))

let coerce = (fun r0 i role kv iv -> (let r = (HyperHeap.new_region r0)
in (let log = (HyperHeap.ralloc r (emp))
in (let ctr = (HyperHeap.ralloc r 0)
in State (((fun r0 i role kv iv r log ctr -> i) r0 i role kv iv r log ctr), ((fun r0 i role kv iv r log ctr -> role) r0 i role kv iv r log ctr), ((fun r0 i role kv iv r log ctr -> r) r0 i role kv iv r log ctr), kv, iv, log, ctr)))))

let leak = (fun i role s -> (Platform.Bytes.op_At_Bar ((fun _proj_ -> (match (_proj_) with
| State (i, r, region, key, iv, log, counter) -> begin
key
end)) s) ((fun _proj_ -> (match (_proj_) with
| State (i, r, region, key, iv, log, counter) -> begin
iv
end)) s)))

let enc = (fun i e ad r p -> (let _40_128 = (Support.Prims.admit ())
in (Support.Prims.magic ())))

let encrypt = (fun i e ad rg p -> (let _40_146 = ()
in (let tlen = (Range.targetLength i rg)
in (let p0 = if (TLSInfo.safeId i) then begin
(Platform.Bytes.createBytes tlen '\x00')
end else begin
(LHAEPlain.repr i ad rg p)
end
in (let _40_150 = ()
in (let c = (enc i e ad (Range.cipherRangeClass i tlen) p0)
in (let _40_153 = ()
in c)))))))

let dec = (fun i d ad c -> (let _40_167 = (Support.Prims.admit ())
in (Support.Prims.magic ())))

let matches = (fun i c ad _40_178 -> (match (_40_178) with
| Entry (_40_4007, c', ad', _) -> begin
((c = c') && (ad = ad'))
end))

let decrypt = (fun i d ad c -> (let _40_198 = ()
in (let res = (dec i d ad c)
in (let log = (HyperHeap.op_Bang (((fun _proj_ -> (match (_proj_) with
| State (i, r, region, key, iv, log, counter) -> begin
log
end))  d)))
in if (TLSInfo.safeId i) then begin
(match ((seq_find (matches ((fun i d ad c res log -> i) i d ad c res log) c ad) log)) with
| None -> begin
None
end
| Some (e) -> begin
Some (((fun _proj_ -> (match (_proj_) with
| Entry (i, c, ad, p) -> begin
p
end)) e))
end)
end else begin
res
end))))




